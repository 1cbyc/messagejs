/**
 * @file Contains utility functions for symmetric encryption and decryption.
 *
 * This module uses the built-in Node.js crypto library to perform AES-256-GCM
 * authenticated encryption. This is used to securely store sensitive data,
 * such as third-party service credentials, in the database.
 *
 * It relies on a 32-byte (256-bit) encryption key provided via the
 * ENCRYPTION_KEY environment variable.
 */

import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';
import logger from '../lib/logger';

// Define the encryption algorithm and parameters.
// AES-256-GCM is a modern, secure choice for authenticated encryption,
// meaning it provides both confidentiality and data integrity.
const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16; // Initialization Vector length (128 bits)

// Retrieve the encryption key from environment variables.
// This key MUST be kept secret and should be a 32-character (256-bit) string.
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;

// A critical security check to ensure the application fails fast if the
// encryption key is not configured correctly.
if (!ENCRYPTION_KEY || Buffer.from(ENCRYPTION_KEY, 'utf-8').length !== 32) {
  throw new Error(
    'FATAL: ENCRYPTION_KEY environment variable is missing, or is not 32 bytes long.',
  );
}

/**
 * Encrypts a plaintext string using AES-256-GCM.
 *
 * The output is a single string containing the IV, auth tag, and encrypted
 * content, separated by colons. This format makes it easy to store and
 * later decrypt.
 *
 * @param {string} text The plaintext string to encrypt.
 * @returns {string} The encrypted string, formatted as "iv:authTag:encryptedContent".
 */
export const encrypt = (text: string): string => {
  // Generate a new, random Initialization Vector (IV) for each encryption.
  // Using the same IV for the same key compromises security.
  const iv = randomBytes(IV_LENGTH);

  // Create the AES-256-GCM cipher instance.
  const cipher = createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_KEY), iv);

  // Encrypt the plaintext.
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  // Get the authentication tag, which is used to verify the integrity of the data during decryption.
  const authTag = cipher.getAuthTag();

  // Combine the IV, auth tag, and encrypted content into a single, colon-separated string.
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
};

/**
 * Decrypts an AES-256-GCM encrypted string.
 *
 * This function expects the input string to be in the format generated by the
 * `encrypt` function ("iv:authTag:encryptedContent").
 *
 * @param {string} encryptedText The encrypted string to decrypt.
 * @returns {string} The original plaintext.
 * @throws {Error} If the encrypted text is malformed or if decryption fails (e.g., tampered data).
 */
export const decrypt = (encryptedText: string): string => {
  try {
    const parts = encryptedText.split(':');
    if (parts.length !== 3) {
      throw new Error('Invalid encrypted text format. Expected "iv:authTag:encryptedContent".');
    }

    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encryptedContent = parts[2];

    // Create the decipher instance.
    const decipher = createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_KEY), iv);

    // Set the authentication tag. This is a critical step for verifying data integrity.
    // If the data was tampered with, this call will throw an error.
    decipher.setAuthTag(authTag);

    // Decrypt the content.
    let decrypted = decipher.update(encryptedContent, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  } catch (error) {
    // Log the decryption error for security auditing but return a generic message.
    logger.error({ error }, 'Decryption failed - possible tampering or corruption');
    throw new Error('Failed to decrypt data. The data may be corrupt or tampered with.');
  }
};
